#!/usr/bin/env python
import os
import sys
from os.path import join, getsize
try:
    from collections import OrderedDict
except:
    from ordereddict import OrderedDict
import argparse


size_results = OrderedDict()


def getDirSize(dir_name):
    for root, dirs, files in os.walk(dir_name, topdown=False):
        if root in size_results.keys():
            break
        else:
            size_results[root] = 0

        for name in files:
            try:
                size_results[join(root, name)] = getsize(join(root, name))
                size_results[root] += size_results[join(root, name)]
            except:
                pass

        for d in dirs:
            try:
                size_results[root] += size_results[join(root, d)]
            except:
                pass

    return


def getAllDirSize(dir_name):
    for root, dirs, files in os.walk(dir_name, topdown=True):
        current_depth = root[len(dir_name) + len(os.path.sep):].count(os.path.sep)

        # TODO identify the home folder where .snapshot situated
        # Otherwise, the program is buggy when there is .snapshot in any other
        # folders

        print root
        # ignore the snapshots
        if '.snapshot' in dirs:
            dirs.remove('.snapshot')
        if current_depth == 1:  # the depth 1 is just for cutting the .snapshot
            dirs[:] = []
        if root != '.':
            getDirSize(root)

    # The size of '.'
    root, dirs, files = os.walk(dir_name, topdown=True).next()

    # TODO reuse the part of code
    size_results[root] = 0
    for name in files:
        try:
            size_results[join(root, name)] = getsize(join(root, name))
            size_results[root] += size_results[join(root, name)]
        except:
            pass
    for d in dirs:
        try:
            size_results[root] += size_results[join(root, d)]
        except:
            pass

    return size_results


def printLargeDirs(topNum):
    l = sorted(size_results.items(),key = lambda t:t[1]) # sort dict by values
    num = min(topNum, len(l))
    print '-----------------RESULTS-------------------'
    for i in range(num):
        print "%s : %f M" % (l[len(l) - i - 1][0], l[len(l) - i - 1][1] / 1024.0 / 1024.0)
    print '-------------------------------------------'
    return


def parse_args(options):
    parser = argparse.ArgumentParser(description="Quota analysing tool")
    parser.add_argument(
        "-d", "--dirname", default = ".",
        help = "directory to be analysed")
    parser.add_argument(
        "-n", "--number", type = int, default = 20,
        help = "number of largest directories to print")
    return parser.parse_args()


if __name__ == '__main__':
    options = parse_args(sys.argv[1:])
    getAllDirSize(options.dirname)
    printLargeDirs(options.number)

